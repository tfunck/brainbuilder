<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>brainbuilder.align.align_3d API documentation</title>
<meta name="description" content="Functions to perform 3D volumetric alignment of the inital GM volume to the reference volume." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>brainbuilder.align.align_3d</code></h1>
</header>
<section id="section-intro">
<p>Functions to perform 3D volumetric alignment of the inital GM volume to the reference volume.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Functions to perform 3D volumetric alignment of the inital GM volume to the reference volume.&#34;&#34;&#34;
import os
import re

import ants
import brainbuilder.utils.ants_nibabel as nib
import nibabel
import numpy as np
from brainbuilder.utils.utils import (
    AntsParams,
    shell,
    simple_ants_apply_tfm,
)


def v2w(i: int, step: float, start: float) -&gt; float:
    &#34;&#34;&#34;Converts voxel coordinate to world coordinate.

    :param i: voxel coordinate
    :param step: step size
    :param start: start coordinate
    :return: world coordinate.
    &#34;&#34;&#34;
    return start + i * step


def find_vol_min_max(vol: np.ndarray) -&gt; tuple:
    &#34;&#34;&#34;Finds the min and max spatial coordinate of the srv image.

    :param vol:  image volume
    :return: srvMin, srvMax
    &#34;&#34;&#34;
    profile = np.max(vol, axis=(0, 2))
    if np.sum(profile) == 0:
        print(&#34;Error : empty srv file&#34;)
        exit(1)
    srvMin = np.argwhere(profile &gt;= 0.01)[0][0]
    srvMax = np.argwhere(profile &gt;= 0.01)[-1][0]
    return srvMin, srvMax


def pad_volume(
    vol: np.ndarray,
    max_factor: int,
    affine: np.ndarray,
    min_voxel_size: int = 29,
    direction: list[int] = [1, 1, 1],
) -&gt; tuple[np.ndarray, np.ndarray]:
    &#34;&#34;&#34;Pad the volume so that it can be downsampled by the maximum downsample factor.

    :param vol: volume to pad
    :param max_factor: maximum downsample factor
    :param affine: affine matrix
    :param min_voxel_size: minimum voxel size
    :param direction: direction of the affine matrix
    :return: padded volume, padded affine matrix.
    &#34;&#34;&#34;
    xdim, ydim, zdim = vol.shape

    def padded_dim(dim: int, max_factor: int, min_voxel_size: int) -&gt; int:
        downsampled_dim = np.ceil(dim / 2 ** (max_factor - 1))

        if downsampled_dim &lt; min_voxel_size:
            return np.ceil((min_voxel_size - downsampled_dim) / 2).astype(int)
        else:
            return 0

    x_pad = padded_dim(xdim, max_factor, min_voxel_size)
    y_pad = padded_dim(ydim, max_factor, min_voxel_size)
    z_pad = padded_dim(zdim, max_factor, min_voxel_size)

    vol_padded = np.pad(vol, ((x_pad, x_pad), (y_pad, y_pad), (z_pad, z_pad)))
    affine[0, 3] -= x_pad * abs(affine[0, 0]) * direction[0]
    affine[1, 3] -= y_pad * abs(affine[1, 1]) * direction[1]
    affine[2, 3] -= z_pad * abs(affine[2, 2]) * direction[2]

    return vol_padded, affine


def get_ref_info(ref_rsl_fn: str) -&gt; tuple:
    &#34;&#34;&#34;Get reference volume information.

    Description: Get the width, min, max, ystep, and ystart of the reference volume

    :param ref_rsl_fn: reference volume filename
    :return: ref_width, ref_min, ref_max, ref_ystep, ref_ystart.
    &#34;&#34;&#34;
    ref_img = nib.load(ref_rsl_fn)
    ref_vol = ref_img.get_fdata()
    ref_vol.shape[1]

    ref_ystep = abs(ref_img.affine[1, 1])
    ref_ystart = ref_img.affine[1, 3]
    ref_min, ref_max = list(
        map(lambda x: v2w(x, ref_ystep, ref_ystart), find_vol_min_max(ref_vol))
    )
    ref_width = ref_max - ref_min

    return ref_width, ref_min, ref_max, ref_ystep, ref_ystart


def pad_seg_vol(seg_rsl_fn: str, max_downsample_level: str) -&gt; str:
    &#34;&#34;&#34;Pad a volume to center it while keeping it centered in the world coordinates.

    :param seg_rsl_fn: segmentation volume filename
    :param max_downsample_level: maximum downsample level
    :return: padded segmentation volume filename
    &#34;&#34;&#34;
    seg_img = nib.load(seg_rsl_fn)
    seg_vol = seg_img.get_fdata()

    ants_img = ants.image_read(seg_rsl_fn)
    direction = ants_img.direction
    com0 = ants.get_center_of_mass(ants_img)

    pad_seg_vol, pad_affine = pad_volume(
        seg_vol,
        max_downsample_level,
        seg_img.affine,
        direction=direction[[0, 1, 2], [0, 1, 2]],
    )

    seg_rsl_pad_fn = re.sub(&#34;.nii&#34;, &#34;_padded.nii&#34;, seg_rsl_fn)

    nib.Nifti1Image(
        pad_seg_vol, pad_affine, direction=direction, dtype=np.uint8
    ).to_filename(seg_rsl_pad_fn)

    com1 = ants.get_center_of_mass(ants.image_read(seg_rsl_pad_fn))

    com_error = np.sqrt(np.sum(np.power(np.array(com0) - np.array(com1), 2)))

    assert (
        com_error &lt; 0.1
    ), f&#34;Error: change in ceter of mass after padding {com0}, {com1}&#34;
    return seg_rsl_pad_fn


def get_alignment_schedule(
    resolution_list: list[int],
    resolution: int,
    resolution_cutoff_for_cc: float = 0.3,
    base_nl_itr: int = 200,
    base_lin_itr: int = 500,
) -&gt; tuple:
    &#34;&#34;&#34;Get the alignment schedule for the linear and nonlinear portions of the ants alignment.

    :param resolution_list: list of resolutions
    :param resolution: resolution of the section volume
    :param resolution_cutoff_for_cc: resolution cutoff for cross correlation
    :param base_nl_itr: base number of iterations for nonlinear alignment
    :param base_lin_itr: base number of iterations for linear alignment
    :return: max_downsample_level, linParams, nlParams, ccParams.
    &#34;&#34;&#34;
    # cur_res/res = 2^(f-1) --&gt; f = 1+ log2(cur_res/res)
    # min_nl_itr = len( [ resolution for resolution in resolution_list[0:resolution_itr] if  float(resolution) &lt;= .1 ] ) # I gues this is to limit nl alignment above 0.1mm
    base_cc_itr = np.rint(base_nl_itr / 2)

    resolution_list = [float(r) for r in resolution_list]

    # Masks work really poorly when separating the temporal lobe
    # seems to be only true with masks --&gt; Mattes works MUCH better than GC for separating the temporal lobe from the frontal lobe
    # because of mask --&gt; However, Mattes[bins=32] failed at 1mm
    # CC APPEARS TO BE VERY IMPORTANT, especially for temporal lobe

    cc_resolution_list = [
        r for r in resolution_list if float(r) &gt; resolution_cutoff_for_cc
    ]
    linParams = AntsParams(resolution_list, resolution, base_lin_itr)
    print(&#34;\t\t\tLinear:&#34;)
    print(&#34;\t\t\t\t&#34;, linParams.itr_str)
    print(&#34;\t\t\t\t&#34;, linParams.f_str)
    print(&#34;\t\t\t\t&#34;, linParams.s_str)

    # resolution_list_lo = [ f for r in resolution_listdd ]
    # max_GC_resolution = 1.
    # GC_resolution = max(resolution, max_GC_resolution)

    # nlParams = AntsParams(resolution_list, resolution, base_nl_itr, max_resolution=1.0)
    nlParams = AntsParams(resolution_list, resolution, base_nl_itr)

    print(&#34;\t\t\t&#34;, &#34;Nonlinear&#34;)
    print(&#34;\t\t\t\t&#34;, nlParams.itr_str)
    print(&#34;\t\t\t\t&#34;, nlParams.s_str)
    print(&#34;\t\t\t\t&#34;, nlParams.f_str)

    max(min(cc_resolution_list), resolution)
    ccParams = AntsParams(resolution_list, resolution, base_cc_itr)

    print(&#34;\t\t\t&#34;, &#34;Nonlinear (CC)&#34;)
    print(&#34;\t\t\t\t&#34;, ccParams.itr_str)
    print(&#34;\t\t\t\t&#34;, ccParams.f_str)
    print(&#34;\t\t\t\t&#34;, ccParams.s_str)

    max_downsample_level = linParams.max_downsample_factor

    return max_downsample_level, linParams, nlParams, ccParams


def write_ref_chunk(
    sub: str,
    hemi: str,
    chunk: int,
    ref_rsl_fn: str,
    out_dir: str,
    y0w: float,
    y0: int,
    y1: int,
    resolution: float,
    ref_ystep: float,
    ref_ystart: float,
    max_downsample_level: int,
    clobber: bool = False,
) -&gt; None:
    &#34;&#34;&#34;Write a chunk from the reference volume that corresponds to the tissue chunk from the section volume.

    :param sub: subject id
    :param hemi: hemisphere
    :param chunk: chunk number
    :param ref_rsl_fn: reference volume filename
    :param out_dir: output directory
    :param y0w: y0 in world coordinates
    :param y0: y0 in voxel coordinates
    :param y1: y1 in voxel coordinates
    :param resolution: resolution of the section volume
    :param ref_ystep: ystep of the reference volume
    :param ref_ystart: ystart of the reference volume
    :param max_downsample_level: maximum downsample level
    :param clobber: overwrite existing files
    :return: None
    &#34;&#34;&#34;
    ref_chunk_fn = f&#34;{out_dir}/{sub}_{hemi}_{chunk}_{resolution}mm_ref_{y0}_{y1}.nii.gz&#34;
    if not os.path.exists(ref_chunk_fn) or clobber:
        # write srv chunk if it does not exist
        print(f&#34;\t\tWriting srv chunk for file\n\n{ref_rsl_fn}&#34;)
        ref_img = nib.load(ref_rsl_fn)
        direction = np.array(ref_img.direction)
        ref_vol = ref_img.get_fdata()
        aff = ref_img.affine

        real_aff = nibabel.load(ref_rsl_fn).affine
        real_aff[1, 1]
        real_aff[1, 3]
        aff[1, 3] = direction[1, 1] * y0w

        ref_chunk = ref_vol[:, y0:y1, :]

        pad_ref_chunk, pad_aff = pad_volume(
            ref_chunk,
            max_downsample_level,
            aff,
            direction=direction[[0, 1, 2], [0, 1, 2]],
        )

        nib.Nifti1Image(
            pad_ref_chunk,
            pad_aff,
            direction=direction,
            dtype=np.uint8,
        ).to_filename(ref_chunk_fn)

    return ref_chunk_fn


def run_alignment(
    out_dir: str,
    out_tfm_fn: str,
    out_inv_fn: str,
    out_fn: str,
    ref_rsl_fn: str,
    ref_chunk_fn: str,
    seg_rsl_fn: str,
    linParams: AntsParams,
    nlParams: AntsParams,
    ccParams: AntsParams,
    resolution: float,
    metric: str = &#34;GC&#34;,
    nbins: int = 32,
    use_init_tfm: bool = False,
    use_masks: bool = True,
    sampling: float = 0.9,
    clobber: bool = False,
) -&gt; None:
    &#34;&#34;&#34;Run the alignment of the tissue chunk to the chunk from the reference volume.

    :param out_dir: output directory
    :param out_tfm_fn: output transformation filename
    :param out_inv_fn: output inverse transformation filename
    :param out_fn: output filename
    :param ref_rsl_fn: reference volume filename
    :param ref_chunk_fn: reference chunk filename
    :param seg_rsl_fn: segmentation volume filename
    :param linParams: linear parameters
    :param nlParams: nonlinear parameters
    :param ccParams: cross correlation parameters
    :param resolution: resolution of the section volume
    :param metric: metric to use for registration
    :param nbins: number of bins for registration
    :param use_init_tfm: use initial transformation
    :param use_masks: use masks for registration
    :param sampling: sampling for registration
    :param clobber: overwrite existing files
    :return: None.
    &#34;&#34;&#34;
    prefix = re.sub(&#34;_SyN_CC_Composite.h5&#34;, &#34;&#34;, out_tfm_fn)  # FIXME this is bad coding
    f&#34;{prefix}/log.txt&#34;

    prefix + &#34;_init_&#34;
    prefix_rigid = prefix + &#34;_Rigid_&#34;
    prefix_similarity = prefix + &#34;_Similarity_&#34;
    prefix_affine = prefix + &#34;_Affine_&#34;
    prefix_manual = prefix + &#34;_Manual_&#34;

    affine_out_fn = f&#34;{prefix_affine}volume.nii.gz&#34;
    affine_inv_fn = f&#34;{prefix_affine}volume_inverse.nii.gz&#34;
    f&#34;{prefix_manual}Composite.nii.gz&#34;

    ref_tgt_fn = ref_chunk_fn
    step = 0.5
    nbins = 32
    sampling = 0.9

    nl_metric = f&#34;Mattes[{ref_chunk_fn},{seg_rsl_fn},1,32,Random,{sampling}]&#34;
    cc_metric = f&#34;CC[{ref_chunk_fn},{seg_rsl_fn},1,3,Random,{sampling}]&#34;

    syn_rate = &#34;0.1&#34;

    base = &#34;antsRegistration -v 1 -a 1 -d 3 &#34;

    def write_log(prefix: str, kind: str, cmd: str) -&gt; None:
        with open(f&#34;{prefix}/log_{kind}.txt&#34;, &#34;w+&#34;) as F:
            F.write(cmd)
        return None

    # set initial transform
    # calculate rigid registration

    init_str = f&#34; --initial-moving-transform [{ref_chunk_fn},{seg_rsl_fn},1] &#34;

    # calculate rigid registration
    if not os.path.exists(f&#34;{prefix_rigid}Composite.h5&#34;):
        rigid_cmd = f&#34;{base}  {init_str}  -t Rigid[{step}]  -m {metric}[{ref_chunk_fn},{seg_rsl_fn},1,{nbins},Random,{sampling}]  -s {linParams.s_str} -f {linParams.f_str}  -c {linParams.itr_str}  -o [{prefix_rigid},{prefix_rigid}volume.nii.gz,{prefix_rigid}volume_inverse.nii.gz] &#34;
        shell(rigid_cmd, verbose=True)
        write_log(out_dir, &#34;rigid&#34;, rigid_cmd)

    # calculate similarity registration
    if not os.path.exists(f&#34;{prefix_similarity}Composite.h5&#34;):
        similarity_cmd = f&#34;{base}  --initial-moving-transform  {prefix_rigid}Composite.h5 -t Similarity[{step}]  -m {metric}[{ref_chunk_fn},{seg_rsl_fn},1,{nbins},Random,{sampling}]   -s {linParams.s_str} -f {linParams.f_str} -c {linParams.itr_str}  -o [{prefix_similarity},{prefix_similarity}volume.nii.gz,{prefix_similarity}volume_inverse.nii.gz] &#34;
        shell(similarity_cmd, verbose=True)
        write_log(out_dir, &#34;similarity&#34;, similarity_cmd)

    affine_init = f&#34;--initial-moving-transform {prefix_similarity}Composite.h5&#34;

    # calculate affine registration
    if not os.path.exists(f&#34;{prefix_affine}Composite.h5&#34;):
        affine_cmd = f&#34;{base}  {affine_init} -t Affine[{step}] -m {metric}[{ref_tgt_fn},{seg_rsl_fn},1,{nbins},Random,{sampling}]  -s {linParams.s_str} -f {linParams.f_str}  -c {linParams.itr_str}  -o [{prefix_affine},{affine_out_fn},{affine_inv_fn}] &#34;
        shell(affine_cmd, verbose=True)
        write_log(out_dir, &#34;affine&#34;, affine_cmd)

    prefix_mattes_syn = f&#34;{prefix}_SyN_Mattes_&#34;
    mattes_syn_out_fn = f&#34;{prefix_mattes_syn}volume.nii.gz&#34;
    mattes_syn_inv_fn = f&#34;{prefix_mattes_syn}volume_inverse.nii.gz&#34;

    prefix_cc_syn = f&#34;{prefix}_SyN_CC_&#34;
    cc_syn_out_fn = f&#34;{prefix_cc_syn}volume.nii.gz&#34;
    cc_syn_inv_fn = f&#34;{prefix_cc_syn}volume_inverse.nii.gz&#34;

    if not os.path.exists(f&#34;{prefix_mattes_syn}Composite.h5&#34;):
        f&#34;{prefix_affine}Composite.h5&#34;
        nl_base = f&#34;{base}  --initial-moving-transform {prefix_affine}Composite.h5 -o [{prefix_mattes_syn},{mattes_syn_out_fn},{mattes_syn_inv_fn}] &#34;
        nl_base += f&#34; -t SyN[{syn_rate}] -m {nl_metric}  -s {nlParams.s_str} -f {nlParams.f_str} -c {nlParams.itr_str} &#34;
        shell(nl_base, verbose=True)
        write_log(out_dir, &#34;syn-mattes&#34;, nl_base)

    if not os.path.exists(f&#34;{prefix_cc_syn}Composite.h5&#34;):
        f&#34;{prefix_mattes_syn}Composite.h5&#34;
        nl_base = f&#34;{base}  --initial-moving-transform {prefix_affine}Composite.h5 -o [{prefix_cc_syn},{cc_syn_out_fn},{cc_syn_inv_fn}] &#34;
        nl_base += f&#34; -t SyN[{syn_rate}] -m {cc_metric} -s {ccParams.s_str} -f {ccParams.f_str} -c {ccParams.itr_str}&#34;
        shell(nl_base, verbose=True)
        write_log(out_dir, &#34;syn-cc&#34;, nl_base)

    prefix_syn = prefix_cc_syn
    simple_ants_apply_tfm(seg_rsl_fn, ref_rsl_fn, prefix_syn + &#34;Composite.h5&#34;, out_fn)
    simple_ants_apply_tfm(
        ref_rsl_fn, seg_rsl_fn, prefix_syn + &#34;InverseComposite.h5&#34;, out_inv_fn
    )

    return None


def align_3d(
    sub: str,
    hemi: str,
    chunk: int,
    seg_rsl_fn: str,
    ref_rsl_fn: str,
    out_dir: str,
    out_tfm_fn: str,
    out_tfm_inv_fn: str,
    out_fn: str,
    out_inv_fn: str,
    resolution: int,
    resolution_list: list[int],
    world_chunk_limits: tuple[float, float],
    vox_chunk_limits: tuple[int, int],
    base_nl_itr: int = 200,
    base_lin_itr: int = 500,
    use_masks: bool = False,
    clobber: bool = False,
    verbose: bool = True,
) -&gt; int:
    &#34;&#34;&#34;Align the tissue chunk to the reference volume.

    :param sub: subject id
    :param hemi: hemisphere
    :param chunk: chunk number
    :param seg_rsl_fn: segmentation volume filename
    :param ref_rsl_fn: reference volume filename
    :param out_dir: output directory
    :param out_tfm_fn: output transformation filename
    :param out_tfm_inv_fn: output inverse transformation filename
    :param out_fn: output filename
    :param out_inv_fn: output inverse filename
    :param resolution: resolution of the section volume
    :param resolution_list: list of resolutions
    :param world_chunk_limits: world chunk limits
    :param vox_chunk_limits: voxel chunk limits
    :param base_nl_itr: base number of iterations for nonlinear alignment
    :param base_lin_itr: base number of iterations for linear alignment
    :param use_masks: use masks for registration
    :param clobber: overwrite existing files
    :param verbose: verbose output
    :return: 0.
    &#34;&#34;&#34;
    if not os.path.exists(out_tfm_fn) or not os.path.exists(out_tfm_inv_fn) or clobber:
        print(&#34;\t\t3D Volumetric Alignment&#34;)
        chunk = int(chunk)
        # Load GM volume extracted from donor MRI.
        ref_width, ref_min, ref_max, ref_ystep, ref_ystart = get_ref_info(ref_rsl_fn)

        # get iteration schedules for the linear and non-linear portion of the ants alignment
        # get maximum number steps by which the srv image will be downsampled by
        # with ants, each step means dividing the image size by 2^(level-1)
        (
            max_downsample_level,
            linParams,
            nlParams,
            ccParams,
        ) = get_alignment_schedule(
            resolution_list,
            resolution,
            base_nl_itr=base_nl_itr,
            base_lin_itr=base_lin_itr,
        )

        # pad the segmented volume so that it can be downsampled by the
        # ammount of times specified by max_downsample_level
        seg_pad_fn = pad_seg_vol(seg_rsl_fn, max_downsample_level)

        img = nib.load(ref_rsl_fn)
        img.shape[1]

        # extract chunk from srv and write it
        ref_chunk_fn = write_ref_chunk(
            sub,
            hemi,
            chunk,
            ref_rsl_fn,
            out_dir,
            vox_chunk_limits[0],
            world_chunk_limits[0],
            world_chunk_limits[1],
            resolution,
            ref_ystep,
            ref_ystart,
            max_downsample_level,
        )

        # run ants alignment between segmented volume (from autoradiographs) to chunk extracte
        run_alignment(
            out_dir,
            out_tfm_fn,
            out_inv_fn,
            out_fn,
            ref_rsl_fn,
            ref_chunk_fn,
            seg_pad_fn,
            linParams,
            nlParams,
            ccParams,
            resolution,
            use_masks=use_masks,
            sampling=0.95,
            metric=&#34;Mattes&#34;,
        )

    return 0</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="brainbuilder.align.align_3d.align_3d"><code class="name flex">
<span>def <span class="ident">align_3d</span></span>(<span>sub: str, hemi: str, chunk: int, seg_rsl_fn: str, ref_rsl_fn: str, out_dir: str, out_tfm_fn: str, out_tfm_inv_fn: str, out_fn: str, out_inv_fn: str, resolution: int, resolution_list: list[int], world_chunk_limits: tuple[float, float], vox_chunk_limits: tuple[int, int], base_nl_itr: int = 200, base_lin_itr: int = 500, use_masks: bool = False, clobber: bool = False, verbose: bool = True) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Align the tissue chunk to the reference volume.</p>
<p>:param sub: subject id
:param hemi: hemisphere
:param chunk: chunk number
:param seg_rsl_fn: segmentation volume filename
:param ref_rsl_fn: reference volume filename
:param out_dir: output directory
:param out_tfm_fn: output transformation filename
:param out_tfm_inv_fn: output inverse transformation filename
:param out_fn: output filename
:param out_inv_fn: output inverse filename
:param resolution: resolution of the section volume
:param resolution_list: list of resolutions
:param world_chunk_limits: world chunk limits
:param vox_chunk_limits: voxel chunk limits
:param base_nl_itr: base number of iterations for nonlinear alignment
:param base_lin_itr: base number of iterations for linear alignment
:param use_masks: use masks for registration
:param clobber: overwrite existing files
:param verbose: verbose output
:return: 0.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def align_3d(
    sub: str,
    hemi: str,
    chunk: int,
    seg_rsl_fn: str,
    ref_rsl_fn: str,
    out_dir: str,
    out_tfm_fn: str,
    out_tfm_inv_fn: str,
    out_fn: str,
    out_inv_fn: str,
    resolution: int,
    resolution_list: list[int],
    world_chunk_limits: tuple[float, float],
    vox_chunk_limits: tuple[int, int],
    base_nl_itr: int = 200,
    base_lin_itr: int = 500,
    use_masks: bool = False,
    clobber: bool = False,
    verbose: bool = True,
) -&gt; int:
    &#34;&#34;&#34;Align the tissue chunk to the reference volume.

    :param sub: subject id
    :param hemi: hemisphere
    :param chunk: chunk number
    :param seg_rsl_fn: segmentation volume filename
    :param ref_rsl_fn: reference volume filename
    :param out_dir: output directory
    :param out_tfm_fn: output transformation filename
    :param out_tfm_inv_fn: output inverse transformation filename
    :param out_fn: output filename
    :param out_inv_fn: output inverse filename
    :param resolution: resolution of the section volume
    :param resolution_list: list of resolutions
    :param world_chunk_limits: world chunk limits
    :param vox_chunk_limits: voxel chunk limits
    :param base_nl_itr: base number of iterations for nonlinear alignment
    :param base_lin_itr: base number of iterations for linear alignment
    :param use_masks: use masks for registration
    :param clobber: overwrite existing files
    :param verbose: verbose output
    :return: 0.
    &#34;&#34;&#34;
    if not os.path.exists(out_tfm_fn) or not os.path.exists(out_tfm_inv_fn) or clobber:
        print(&#34;\t\t3D Volumetric Alignment&#34;)
        chunk = int(chunk)
        # Load GM volume extracted from donor MRI.
        ref_width, ref_min, ref_max, ref_ystep, ref_ystart = get_ref_info(ref_rsl_fn)

        # get iteration schedules for the linear and non-linear portion of the ants alignment
        # get maximum number steps by which the srv image will be downsampled by
        # with ants, each step means dividing the image size by 2^(level-1)
        (
            max_downsample_level,
            linParams,
            nlParams,
            ccParams,
        ) = get_alignment_schedule(
            resolution_list,
            resolution,
            base_nl_itr=base_nl_itr,
            base_lin_itr=base_lin_itr,
        )

        # pad the segmented volume so that it can be downsampled by the
        # ammount of times specified by max_downsample_level
        seg_pad_fn = pad_seg_vol(seg_rsl_fn, max_downsample_level)

        img = nib.load(ref_rsl_fn)
        img.shape[1]

        # extract chunk from srv and write it
        ref_chunk_fn = write_ref_chunk(
            sub,
            hemi,
            chunk,
            ref_rsl_fn,
            out_dir,
            vox_chunk_limits[0],
            world_chunk_limits[0],
            world_chunk_limits[1],
            resolution,
            ref_ystep,
            ref_ystart,
            max_downsample_level,
        )

        # run ants alignment between segmented volume (from autoradiographs) to chunk extracte
        run_alignment(
            out_dir,
            out_tfm_fn,
            out_inv_fn,
            out_fn,
            ref_rsl_fn,
            ref_chunk_fn,
            seg_pad_fn,
            linParams,
            nlParams,
            ccParams,
            resolution,
            use_masks=use_masks,
            sampling=0.95,
            metric=&#34;Mattes&#34;,
        )

    return 0</code></pre>
</details>
</dd>
<dt id="brainbuilder.align.align_3d.find_vol_min_max"><code class="name flex">
<span>def <span class="ident">find_vol_min_max</span></span>(<span>vol: numpy.ndarray) ‑> tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Finds the min and max spatial coordinate of the srv image.</p>
<p>:param vol:
image volume
:return: srvMin, srvMax</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_vol_min_max(vol: np.ndarray) -&gt; tuple:
    &#34;&#34;&#34;Finds the min and max spatial coordinate of the srv image.

    :param vol:  image volume
    :return: srvMin, srvMax
    &#34;&#34;&#34;
    profile = np.max(vol, axis=(0, 2))
    if np.sum(profile) == 0:
        print(&#34;Error : empty srv file&#34;)
        exit(1)
    srvMin = np.argwhere(profile &gt;= 0.01)[0][0]
    srvMax = np.argwhere(profile &gt;= 0.01)[-1][0]
    return srvMin, srvMax</code></pre>
</details>
</dd>
<dt id="brainbuilder.align.align_3d.get_alignment_schedule"><code class="name flex">
<span>def <span class="ident">get_alignment_schedule</span></span>(<span>resolution_list: list[int], resolution: int, resolution_cutoff_for_cc: float = 0.3, base_nl_itr: int = 200, base_lin_itr: int = 500) ‑> tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Get the alignment schedule for the linear and nonlinear portions of the ants alignment.</p>
<p>:param resolution_list: list of resolutions
:param resolution: resolution of the section volume
:param resolution_cutoff_for_cc: resolution cutoff for cross correlation
:param base_nl_itr: base number of iterations for nonlinear alignment
:param base_lin_itr: base number of iterations for linear alignment
:return: max_downsample_level, linParams, nlParams, ccParams.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_alignment_schedule(
    resolution_list: list[int],
    resolution: int,
    resolution_cutoff_for_cc: float = 0.3,
    base_nl_itr: int = 200,
    base_lin_itr: int = 500,
) -&gt; tuple:
    &#34;&#34;&#34;Get the alignment schedule for the linear and nonlinear portions of the ants alignment.

    :param resolution_list: list of resolutions
    :param resolution: resolution of the section volume
    :param resolution_cutoff_for_cc: resolution cutoff for cross correlation
    :param base_nl_itr: base number of iterations for nonlinear alignment
    :param base_lin_itr: base number of iterations for linear alignment
    :return: max_downsample_level, linParams, nlParams, ccParams.
    &#34;&#34;&#34;
    # cur_res/res = 2^(f-1) --&gt; f = 1+ log2(cur_res/res)
    # min_nl_itr = len( [ resolution for resolution in resolution_list[0:resolution_itr] if  float(resolution) &lt;= .1 ] ) # I gues this is to limit nl alignment above 0.1mm
    base_cc_itr = np.rint(base_nl_itr / 2)

    resolution_list = [float(r) for r in resolution_list]

    # Masks work really poorly when separating the temporal lobe
    # seems to be only true with masks --&gt; Mattes works MUCH better than GC for separating the temporal lobe from the frontal lobe
    # because of mask --&gt; However, Mattes[bins=32] failed at 1mm
    # CC APPEARS TO BE VERY IMPORTANT, especially for temporal lobe

    cc_resolution_list = [
        r for r in resolution_list if float(r) &gt; resolution_cutoff_for_cc
    ]
    linParams = AntsParams(resolution_list, resolution, base_lin_itr)
    print(&#34;\t\t\tLinear:&#34;)
    print(&#34;\t\t\t\t&#34;, linParams.itr_str)
    print(&#34;\t\t\t\t&#34;, linParams.f_str)
    print(&#34;\t\t\t\t&#34;, linParams.s_str)

    # resolution_list_lo = [ f for r in resolution_listdd ]
    # max_GC_resolution = 1.
    # GC_resolution = max(resolution, max_GC_resolution)

    # nlParams = AntsParams(resolution_list, resolution, base_nl_itr, max_resolution=1.0)
    nlParams = AntsParams(resolution_list, resolution, base_nl_itr)

    print(&#34;\t\t\t&#34;, &#34;Nonlinear&#34;)
    print(&#34;\t\t\t\t&#34;, nlParams.itr_str)
    print(&#34;\t\t\t\t&#34;, nlParams.s_str)
    print(&#34;\t\t\t\t&#34;, nlParams.f_str)

    max(min(cc_resolution_list), resolution)
    ccParams = AntsParams(resolution_list, resolution, base_cc_itr)

    print(&#34;\t\t\t&#34;, &#34;Nonlinear (CC)&#34;)
    print(&#34;\t\t\t\t&#34;, ccParams.itr_str)
    print(&#34;\t\t\t\t&#34;, ccParams.f_str)
    print(&#34;\t\t\t\t&#34;, ccParams.s_str)

    max_downsample_level = linParams.max_downsample_factor

    return max_downsample_level, linParams, nlParams, ccParams</code></pre>
</details>
</dd>
<dt id="brainbuilder.align.align_3d.get_ref_info"><code class="name flex">
<span>def <span class="ident">get_ref_info</span></span>(<span>ref_rsl_fn: str) ‑> tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Get reference volume information.</p>
<p>Description: Get the width, min, max, ystep, and ystart of the reference volume</p>
<p>:param ref_rsl_fn: reference volume filename
:return: ref_width, ref_min, ref_max, ref_ystep, ref_ystart.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ref_info(ref_rsl_fn: str) -&gt; tuple:
    &#34;&#34;&#34;Get reference volume information.

    Description: Get the width, min, max, ystep, and ystart of the reference volume

    :param ref_rsl_fn: reference volume filename
    :return: ref_width, ref_min, ref_max, ref_ystep, ref_ystart.
    &#34;&#34;&#34;
    ref_img = nib.load(ref_rsl_fn)
    ref_vol = ref_img.get_fdata()
    ref_vol.shape[1]

    ref_ystep = abs(ref_img.affine[1, 1])
    ref_ystart = ref_img.affine[1, 3]
    ref_min, ref_max = list(
        map(lambda x: v2w(x, ref_ystep, ref_ystart), find_vol_min_max(ref_vol))
    )
    ref_width = ref_max - ref_min

    return ref_width, ref_min, ref_max, ref_ystep, ref_ystart</code></pre>
</details>
</dd>
<dt id="brainbuilder.align.align_3d.pad_seg_vol"><code class="name flex">
<span>def <span class="ident">pad_seg_vol</span></span>(<span>seg_rsl_fn: str, max_downsample_level: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Pad a volume to center it while keeping it centered in the world coordinates.</p>
<p>:param seg_rsl_fn: segmentation volume filename
:param max_downsample_level: maximum downsample level
:return: padded segmentation volume filename</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pad_seg_vol(seg_rsl_fn: str, max_downsample_level: str) -&gt; str:
    &#34;&#34;&#34;Pad a volume to center it while keeping it centered in the world coordinates.

    :param seg_rsl_fn: segmentation volume filename
    :param max_downsample_level: maximum downsample level
    :return: padded segmentation volume filename
    &#34;&#34;&#34;
    seg_img = nib.load(seg_rsl_fn)
    seg_vol = seg_img.get_fdata()

    ants_img = ants.image_read(seg_rsl_fn)
    direction = ants_img.direction
    com0 = ants.get_center_of_mass(ants_img)

    pad_seg_vol, pad_affine = pad_volume(
        seg_vol,
        max_downsample_level,
        seg_img.affine,
        direction=direction[[0, 1, 2], [0, 1, 2]],
    )

    seg_rsl_pad_fn = re.sub(&#34;.nii&#34;, &#34;_padded.nii&#34;, seg_rsl_fn)

    nib.Nifti1Image(
        pad_seg_vol, pad_affine, direction=direction, dtype=np.uint8
    ).to_filename(seg_rsl_pad_fn)

    com1 = ants.get_center_of_mass(ants.image_read(seg_rsl_pad_fn))

    com_error = np.sqrt(np.sum(np.power(np.array(com0) - np.array(com1), 2)))

    assert (
        com_error &lt; 0.1
    ), f&#34;Error: change in ceter of mass after padding {com0}, {com1}&#34;
    return seg_rsl_pad_fn</code></pre>
</details>
</dd>
<dt id="brainbuilder.align.align_3d.pad_volume"><code class="name flex">
<span>def <span class="ident">pad_volume</span></span>(<span>vol: numpy.ndarray, max_factor: int, affine: numpy.ndarray, min_voxel_size: int = 29, direction: list[int] = [1, 1, 1]) ‑> tuple[numpy.ndarray, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Pad the volume so that it can be downsampled by the maximum downsample factor.</p>
<p>:param vol: volume to pad
:param max_factor: maximum downsample factor
:param affine: affine matrix
:param min_voxel_size: minimum voxel size
:param direction: direction of the affine matrix
:return: padded volume, padded affine matrix.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pad_volume(
    vol: np.ndarray,
    max_factor: int,
    affine: np.ndarray,
    min_voxel_size: int = 29,
    direction: list[int] = [1, 1, 1],
) -&gt; tuple[np.ndarray, np.ndarray]:
    &#34;&#34;&#34;Pad the volume so that it can be downsampled by the maximum downsample factor.

    :param vol: volume to pad
    :param max_factor: maximum downsample factor
    :param affine: affine matrix
    :param min_voxel_size: minimum voxel size
    :param direction: direction of the affine matrix
    :return: padded volume, padded affine matrix.
    &#34;&#34;&#34;
    xdim, ydim, zdim = vol.shape

    def padded_dim(dim: int, max_factor: int, min_voxel_size: int) -&gt; int:
        downsampled_dim = np.ceil(dim / 2 ** (max_factor - 1))

        if downsampled_dim &lt; min_voxel_size:
            return np.ceil((min_voxel_size - downsampled_dim) / 2).astype(int)
        else:
            return 0

    x_pad = padded_dim(xdim, max_factor, min_voxel_size)
    y_pad = padded_dim(ydim, max_factor, min_voxel_size)
    z_pad = padded_dim(zdim, max_factor, min_voxel_size)

    vol_padded = np.pad(vol, ((x_pad, x_pad), (y_pad, y_pad), (z_pad, z_pad)))
    affine[0, 3] -= x_pad * abs(affine[0, 0]) * direction[0]
    affine[1, 3] -= y_pad * abs(affine[1, 1]) * direction[1]
    affine[2, 3] -= z_pad * abs(affine[2, 2]) * direction[2]

    return vol_padded, affine</code></pre>
</details>
</dd>
<dt id="brainbuilder.align.align_3d.run_alignment"><code class="name flex">
<span>def <span class="ident">run_alignment</span></span>(<span>out_dir: str, out_tfm_fn: str, out_inv_fn: str, out_fn: str, ref_rsl_fn: str, ref_chunk_fn: str, seg_rsl_fn: str, linParams: <a title="brainbuilder.utils.utils.AntsParams" href="../utils/utils.html#brainbuilder.utils.utils.AntsParams">AntsParams</a>, nlParams: <a title="brainbuilder.utils.utils.AntsParams" href="../utils/utils.html#brainbuilder.utils.utils.AntsParams">AntsParams</a>, ccParams: <a title="brainbuilder.utils.utils.AntsParams" href="../utils/utils.html#brainbuilder.utils.utils.AntsParams">AntsParams</a>, resolution: float, metric: str = 'GC', nbins: int = 32, use_init_tfm: bool = False, use_masks: bool = True, sampling: float = 0.9, clobber: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Run the alignment of the tissue chunk to the chunk from the reference volume.</p>
<p>:param out_dir: output directory
:param out_tfm_fn: output transformation filename
:param out_inv_fn: output inverse transformation filename
:param out_fn: output filename
:param ref_rsl_fn: reference volume filename
:param ref_chunk_fn: reference chunk filename
:param seg_rsl_fn: segmentation volume filename
:param linParams: linear parameters
:param nlParams: nonlinear parameters
:param ccParams: cross correlation parameters
:param resolution: resolution of the section volume
:param metric: metric to use for registration
:param nbins: number of bins for registration
:param use_init_tfm: use initial transformation
:param use_masks: use masks for registration
:param sampling: sampling for registration
:param clobber: overwrite existing files
:return: None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_alignment(
    out_dir: str,
    out_tfm_fn: str,
    out_inv_fn: str,
    out_fn: str,
    ref_rsl_fn: str,
    ref_chunk_fn: str,
    seg_rsl_fn: str,
    linParams: AntsParams,
    nlParams: AntsParams,
    ccParams: AntsParams,
    resolution: float,
    metric: str = &#34;GC&#34;,
    nbins: int = 32,
    use_init_tfm: bool = False,
    use_masks: bool = True,
    sampling: float = 0.9,
    clobber: bool = False,
) -&gt; None:
    &#34;&#34;&#34;Run the alignment of the tissue chunk to the chunk from the reference volume.

    :param out_dir: output directory
    :param out_tfm_fn: output transformation filename
    :param out_inv_fn: output inverse transformation filename
    :param out_fn: output filename
    :param ref_rsl_fn: reference volume filename
    :param ref_chunk_fn: reference chunk filename
    :param seg_rsl_fn: segmentation volume filename
    :param linParams: linear parameters
    :param nlParams: nonlinear parameters
    :param ccParams: cross correlation parameters
    :param resolution: resolution of the section volume
    :param metric: metric to use for registration
    :param nbins: number of bins for registration
    :param use_init_tfm: use initial transformation
    :param use_masks: use masks for registration
    :param sampling: sampling for registration
    :param clobber: overwrite existing files
    :return: None.
    &#34;&#34;&#34;
    prefix = re.sub(&#34;_SyN_CC_Composite.h5&#34;, &#34;&#34;, out_tfm_fn)  # FIXME this is bad coding
    f&#34;{prefix}/log.txt&#34;

    prefix + &#34;_init_&#34;
    prefix_rigid = prefix + &#34;_Rigid_&#34;
    prefix_similarity = prefix + &#34;_Similarity_&#34;
    prefix_affine = prefix + &#34;_Affine_&#34;
    prefix_manual = prefix + &#34;_Manual_&#34;

    affine_out_fn = f&#34;{prefix_affine}volume.nii.gz&#34;
    affine_inv_fn = f&#34;{prefix_affine}volume_inverse.nii.gz&#34;
    f&#34;{prefix_manual}Composite.nii.gz&#34;

    ref_tgt_fn = ref_chunk_fn
    step = 0.5
    nbins = 32
    sampling = 0.9

    nl_metric = f&#34;Mattes[{ref_chunk_fn},{seg_rsl_fn},1,32,Random,{sampling}]&#34;
    cc_metric = f&#34;CC[{ref_chunk_fn},{seg_rsl_fn},1,3,Random,{sampling}]&#34;

    syn_rate = &#34;0.1&#34;

    base = &#34;antsRegistration -v 1 -a 1 -d 3 &#34;

    def write_log(prefix: str, kind: str, cmd: str) -&gt; None:
        with open(f&#34;{prefix}/log_{kind}.txt&#34;, &#34;w+&#34;) as F:
            F.write(cmd)
        return None

    # set initial transform
    # calculate rigid registration

    init_str = f&#34; --initial-moving-transform [{ref_chunk_fn},{seg_rsl_fn},1] &#34;

    # calculate rigid registration
    if not os.path.exists(f&#34;{prefix_rigid}Composite.h5&#34;):
        rigid_cmd = f&#34;{base}  {init_str}  -t Rigid[{step}]  -m {metric}[{ref_chunk_fn},{seg_rsl_fn},1,{nbins},Random,{sampling}]  -s {linParams.s_str} -f {linParams.f_str}  -c {linParams.itr_str}  -o [{prefix_rigid},{prefix_rigid}volume.nii.gz,{prefix_rigid}volume_inverse.nii.gz] &#34;
        shell(rigid_cmd, verbose=True)
        write_log(out_dir, &#34;rigid&#34;, rigid_cmd)

    # calculate similarity registration
    if not os.path.exists(f&#34;{prefix_similarity}Composite.h5&#34;):
        similarity_cmd = f&#34;{base}  --initial-moving-transform  {prefix_rigid}Composite.h5 -t Similarity[{step}]  -m {metric}[{ref_chunk_fn},{seg_rsl_fn},1,{nbins},Random,{sampling}]   -s {linParams.s_str} -f {linParams.f_str} -c {linParams.itr_str}  -o [{prefix_similarity},{prefix_similarity}volume.nii.gz,{prefix_similarity}volume_inverse.nii.gz] &#34;
        shell(similarity_cmd, verbose=True)
        write_log(out_dir, &#34;similarity&#34;, similarity_cmd)

    affine_init = f&#34;--initial-moving-transform {prefix_similarity}Composite.h5&#34;

    # calculate affine registration
    if not os.path.exists(f&#34;{prefix_affine}Composite.h5&#34;):
        affine_cmd = f&#34;{base}  {affine_init} -t Affine[{step}] -m {metric}[{ref_tgt_fn},{seg_rsl_fn},1,{nbins},Random,{sampling}]  -s {linParams.s_str} -f {linParams.f_str}  -c {linParams.itr_str}  -o [{prefix_affine},{affine_out_fn},{affine_inv_fn}] &#34;
        shell(affine_cmd, verbose=True)
        write_log(out_dir, &#34;affine&#34;, affine_cmd)

    prefix_mattes_syn = f&#34;{prefix}_SyN_Mattes_&#34;
    mattes_syn_out_fn = f&#34;{prefix_mattes_syn}volume.nii.gz&#34;
    mattes_syn_inv_fn = f&#34;{prefix_mattes_syn}volume_inverse.nii.gz&#34;

    prefix_cc_syn = f&#34;{prefix}_SyN_CC_&#34;
    cc_syn_out_fn = f&#34;{prefix_cc_syn}volume.nii.gz&#34;
    cc_syn_inv_fn = f&#34;{prefix_cc_syn}volume_inverse.nii.gz&#34;

    if not os.path.exists(f&#34;{prefix_mattes_syn}Composite.h5&#34;):
        f&#34;{prefix_affine}Composite.h5&#34;
        nl_base = f&#34;{base}  --initial-moving-transform {prefix_affine}Composite.h5 -o [{prefix_mattes_syn},{mattes_syn_out_fn},{mattes_syn_inv_fn}] &#34;
        nl_base += f&#34; -t SyN[{syn_rate}] -m {nl_metric}  -s {nlParams.s_str} -f {nlParams.f_str} -c {nlParams.itr_str} &#34;
        shell(nl_base, verbose=True)
        write_log(out_dir, &#34;syn-mattes&#34;, nl_base)

    if not os.path.exists(f&#34;{prefix_cc_syn}Composite.h5&#34;):
        f&#34;{prefix_mattes_syn}Composite.h5&#34;
        nl_base = f&#34;{base}  --initial-moving-transform {prefix_affine}Composite.h5 -o [{prefix_cc_syn},{cc_syn_out_fn},{cc_syn_inv_fn}] &#34;
        nl_base += f&#34; -t SyN[{syn_rate}] -m {cc_metric} -s {ccParams.s_str} -f {ccParams.f_str} -c {ccParams.itr_str}&#34;
        shell(nl_base, verbose=True)
        write_log(out_dir, &#34;syn-cc&#34;, nl_base)

    prefix_syn = prefix_cc_syn
    simple_ants_apply_tfm(seg_rsl_fn, ref_rsl_fn, prefix_syn + &#34;Composite.h5&#34;, out_fn)
    simple_ants_apply_tfm(
        ref_rsl_fn, seg_rsl_fn, prefix_syn + &#34;InverseComposite.h5&#34;, out_inv_fn
    )

    return None</code></pre>
</details>
</dd>
<dt id="brainbuilder.align.align_3d.v2w"><code class="name flex">
<span>def <span class="ident">v2w</span></span>(<span>i: int, step: float, start: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Converts voxel coordinate to world coordinate.</p>
<p>:param i: voxel coordinate
:param step: step size
:param start: start coordinate
:return: world coordinate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def v2w(i: int, step: float, start: float) -&gt; float:
    &#34;&#34;&#34;Converts voxel coordinate to world coordinate.

    :param i: voxel coordinate
    :param step: step size
    :param start: start coordinate
    :return: world coordinate.
    &#34;&#34;&#34;
    return start + i * step</code></pre>
</details>
</dd>
<dt id="brainbuilder.align.align_3d.write_ref_chunk"><code class="name flex">
<span>def <span class="ident">write_ref_chunk</span></span>(<span>sub: str, hemi: str, chunk: int, ref_rsl_fn: str, out_dir: str, y0w: float, y0: int, y1: int, resolution: float, ref_ystep: float, ref_ystart: float, max_downsample_level: int, clobber: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Write a chunk from the reference volume that corresponds to the tissue chunk from the section volume.</p>
<p>:param sub: subject id
:param hemi: hemisphere
:param chunk: chunk number
:param ref_rsl_fn: reference volume filename
:param out_dir: output directory
:param y0w: y0 in world coordinates
:param y0: y0 in voxel coordinates
:param y1: y1 in voxel coordinates
:param resolution: resolution of the section volume
:param ref_ystep: ystep of the reference volume
:param ref_ystart: ystart of the reference volume
:param max_downsample_level: maximum downsample level
:param clobber: overwrite existing files
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_ref_chunk(
    sub: str,
    hemi: str,
    chunk: int,
    ref_rsl_fn: str,
    out_dir: str,
    y0w: float,
    y0: int,
    y1: int,
    resolution: float,
    ref_ystep: float,
    ref_ystart: float,
    max_downsample_level: int,
    clobber: bool = False,
) -&gt; None:
    &#34;&#34;&#34;Write a chunk from the reference volume that corresponds to the tissue chunk from the section volume.

    :param sub: subject id
    :param hemi: hemisphere
    :param chunk: chunk number
    :param ref_rsl_fn: reference volume filename
    :param out_dir: output directory
    :param y0w: y0 in world coordinates
    :param y0: y0 in voxel coordinates
    :param y1: y1 in voxel coordinates
    :param resolution: resolution of the section volume
    :param ref_ystep: ystep of the reference volume
    :param ref_ystart: ystart of the reference volume
    :param max_downsample_level: maximum downsample level
    :param clobber: overwrite existing files
    :return: None
    &#34;&#34;&#34;
    ref_chunk_fn = f&#34;{out_dir}/{sub}_{hemi}_{chunk}_{resolution}mm_ref_{y0}_{y1}.nii.gz&#34;
    if not os.path.exists(ref_chunk_fn) or clobber:
        # write srv chunk if it does not exist
        print(f&#34;\t\tWriting srv chunk for file\n\n{ref_rsl_fn}&#34;)
        ref_img = nib.load(ref_rsl_fn)
        direction = np.array(ref_img.direction)
        ref_vol = ref_img.get_fdata()
        aff = ref_img.affine

        real_aff = nibabel.load(ref_rsl_fn).affine
        real_aff[1, 1]
        real_aff[1, 3]
        aff[1, 3] = direction[1, 1] * y0w

        ref_chunk = ref_vol[:, y0:y1, :]

        pad_ref_chunk, pad_aff = pad_volume(
            ref_chunk,
            max_downsample_level,
            aff,
            direction=direction[[0, 1, 2], [0, 1, 2]],
        )

        nib.Nifti1Image(
            pad_ref_chunk,
            pad_aff,
            direction=direction,
            dtype=np.uint8,
        ).to_filename(ref_chunk_fn)

    return ref_chunk_fn</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="brainbuilder.align" href="index.html">brainbuilder.align</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="brainbuilder.align.align_3d.align_3d" href="#brainbuilder.align.align_3d.align_3d">align_3d</a></code></li>
<li><code><a title="brainbuilder.align.align_3d.find_vol_min_max" href="#brainbuilder.align.align_3d.find_vol_min_max">find_vol_min_max</a></code></li>
<li><code><a title="brainbuilder.align.align_3d.get_alignment_schedule" href="#brainbuilder.align.align_3d.get_alignment_schedule">get_alignment_schedule</a></code></li>
<li><code><a title="brainbuilder.align.align_3d.get_ref_info" href="#brainbuilder.align.align_3d.get_ref_info">get_ref_info</a></code></li>
<li><code><a title="brainbuilder.align.align_3d.pad_seg_vol" href="#brainbuilder.align.align_3d.pad_seg_vol">pad_seg_vol</a></code></li>
<li><code><a title="brainbuilder.align.align_3d.pad_volume" href="#brainbuilder.align.align_3d.pad_volume">pad_volume</a></code></li>
<li><code><a title="brainbuilder.align.align_3d.run_alignment" href="#brainbuilder.align.align_3d.run_alignment">run_alignment</a></code></li>
<li><code><a title="brainbuilder.align.align_3d.v2w" href="#brainbuilder.align.align_3d.v2w">v2w</a></code></li>
<li><code><a title="brainbuilder.align.align_3d.write_ref_chunk" href="#brainbuilder.align.align_3d.write_ref_chunk">write_ref_chunk</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>